---
title: "Untitled"
format: html
---

## Task 1

a) Specify a temporal windows for in which to measure Euclidean distances
b) Measure the distance from every point to every other point within this temporal window 
c) Remove “static points”: These are points where the average distance is less than a given threshold. This segments the trajectory into subtrajectories
d) Now remove short subtrajectories: These are trajectories with a short duration (whereas “short” is tbd)

```{r setup, include=FALSE}
library("readr")
library("dplyr")
library("ggplot2")

```

## Step 1: Sabi movment

```{r}
wildschwein <- read_delim("wildschwein_BE_2056.csv", ",")

as.POSIXct("2015-07-01", tz="UTC")

sabi <- as.POSIXct(sabi$DatetimeUTC, tz="UTC")

sabi <- wildschwein |>
    filter(TierName == "Sabi") |> 
         filter( DatetimeUTC >= as.POSIXct("2015-07-01", tz="UTC"), 
                 DatetimeUTC < as.POSIXct("2015-07-03", tz="UTC"))  #filter Sabi and choose a certain time length


```

```{r}
ggplot(sabi, aes(E,N, color= DatetimeUTC)) +
  geom_point() +
  geom_path() +
  coord_equal()
```



## Step a): Specify a temporal window 
In the above dataset, the sampling interval is 15 minutes. If we take a temporal window of 60 minutes, that would mean including 4 fixes. We need to calculate the following Euclidean distances (pos representing single location):

pos[n-2] to pos[n]
pos[n-1] to pos[n]
pos[n] to pos[n+1]
pos[n] to pos[n+2]

```{r}
#visualise if time stamps are even (every 15 min v.e.)
sabi |> 
  head(50) |> 
  ggplot(aes(DatetimeUTC, 1))+
  geom_point()

#steplength
sabi <- sabi |> 
  mutate(steplength = sqrt((lead(E)-E)^2 +(lead(N)-N)^2))
```
##Step b)
Measure the distance from every point to every other point within this temporal window 
Just like last week, we use the formula for calculating the Euclidean distance in in combination with lead() and lag(). For example, to create the necessary offset of n-2, we use lag(x, 2). For each offset, we create one individual column.

```{r}
#steplength beginning end with lead and lag (computating values)

sabi <-sabi |> 
  mutate(
    n_plus1 = sqrt((lead(E,1)-E)^2 +(lead(N,1)-N)^2),
    n_plus2 = sqrt((lead(E,2)-E)^2 +(lead(N,2)-N)^2),
    n_minus1 = sqrt((lag(E,1)-E)^2 +(lag(N,1)-N)^2),
    n_minus2 = sqrt((lag(E,2)-E)^2 +(lag(N,2)-N)^2)
    )

# calculate mean of lead and lag values

sabi <- sabi |> 
  rowwise() |> 
  mutate(
    stepMean =mean(c(n_minus1, n_minus2, n_plus1, n_plus2))
  ) |> 
  ungroup()
```
## Step c): Remove “static points”
We can now determine if an animal is moving or not by specifying a threshold distance on stepMean. In our example, we use the mean value as a threshold: Positions with distances below this value are considered static.

```{r}
#visualise step Mean

ggplot(sabi, aes(stepMean))+
  geom_histogram(binwidth =10)+
  geom_vline(xintercept =mean(sabi$stepMean, na.rm=TRUE))

sabi <- sabi |>
    ungroup() |>
    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

sabi_filter <- sabi |>
    filter(!static)

sabi_filter |>
    ggplot(aes(E, N)) +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "bottom")


# static column describes threshold of stepmean to say if its true or false
sabi |> 
  mutate(static =stepMean < mean(stepMean, na.rm =TRUE)) |> 
  ggplot(aes(E,N))+
  geom_path()+
  geom_point(aes(color=static))+
  coord_fixed()
```

